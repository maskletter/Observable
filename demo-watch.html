<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        /* 表示给所有class包含container的元素添加样式 */
        .container{  }
        /* 表示class包含container的元素内所有class包含wrapper的元素添加样式 */
        .container .wrapper{  }
        /* 表示给id为pp的元素设置样式 */
        #pp{  }
        /* 表示给标签为div，并且class包含test-1的元素添加样式 */
        div.test-1{  }
        /* 表示给class包含wrapper的元素的孩子(儿子辈)里，id为pp2的元素设置样式 */
        .wrapper>#pp2{  }
        
    </style>
</head>
<body>
    <!-- 这里个导航的布局 -->
    <div>
        <div style="text-align:color">
            <a href=""></a>
            <a href=""></a>
            <a href=""></a>
            <a href=""></a>
        </div>
    </div>
    <!-- 这个大图片的布局 -->
    <div>
        <img src="banner" alt="">
    </div>
    <div class="container">                     <!--张三-->
        <div class="wrapper">                       <!--李四：张三的儿子-->
            <div></div>                                 <!--王五：张三的孙子，李四的儿子-->
            <a href=""></a>                             <!--王五：张三的孙子，李四的儿子-->
            <p id="pp"></p>                             <!--王五：张三的孙子，李四的儿子-->
            <p id="pp2"></p>                            <!--王五：张三的孙子，李四的儿子-->
            <div class="test-1"></div>                  <!--王五：张三的孙子，李四的儿子-->
            <text class="test-1"></text>                <!--王五：张三的孙子，李四的儿子-->
        </div>
    </div>
    <svg >
        <defs>
            <pattern id="raduisImage" patternUnits="userSpaceOnUse" width="304" height="223">
                <image xlink:href="https://dss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1113595036,2524089961&fm=58" x="0" y="0" width="304" height="223" />
            </pattern>
        </defs>
        <!-- <path d="M 130 110 C 130 80, 170 80, 170 110 V 130 140 H140,130 V 130 110" stroke="black" fill="url(#raduisImage)"/> -->
        <path d="M 0 50 C 0 -10, 100 -10, 100 50 V 130 140 H 0 0 V 50 50" fill="url(#raduisImage)"/>
      </svg> 
    
<!-- <svg version="1.1" >


<path d="M130 25  A 30 30 0 0 1 55 25" stroke="black" fill="green" stroke-width="2" fill-opacity="0.5"/>
 
</svg> -->
<script>
    const data = {
        name: "tom",
        age: 14,
        friend: {
                "name1": "张三",
                "name2": "李四",
                "name3": "王五",
                "name4": "赵六"
        },
        school: ["北京大学","河北大学","xx大学"]
    }
    //object是监听的对象
    //key是监听对象的key
    //value是监听对象的值
    //path是父级的key，数组合集
    //event是一个监听回调( event:{ get(){},set(){} } )
    const defineProperty = (object, key, value, path, event) => {
        Object.defineProperty(object, key, {
            get(){
                event.get && event.get(path)
                return value
            },
            set(val){
                event.set && event.set(path, val)
                value = val
            }
        })
    }
    const createNewWatch = (val, path, parentKey, event) => {
       //如果值不是object类型，那么直接返回此值
       if(typeof val != 'object') return val;
       //反之如果是object类型，那么调用WatchObject，在进行子元素的遍历及监听
       //WatchObject会在下面的代码中进行创建
       if(val instanceof Array){
           //是个是数组的话就走刚才创建的数组对象
           return WatchArray(val,path.concat(parentKey), event)
       }
       return WatchObject(val,path.concat(parentKey), event)
    }
    const WatchArray = (data, path, event) => {
        function WatchArray(){
            data.forEach(v => this.push(v))
        }
        WatchArray.prototype = []
        WatchArray.prototype.constructor = Array;
        WatchArray.prototype.push = function(val){
            const key = this.length
            val = createNewWatch(val, path, key, event)
            Array.prototype.push.call(this,val)
            defineProperty(this, key, val, path.concat(key), event)
        }
        WatchArray.prototype.unshift = function(val){
            const key = this.length
            val = createNewWatch(val, path, key, event)
            Array.prototype.unshift.call(this,val)
            defineProperty(this, key, this[key], path.concat(key), event)
        }
        WatchArray.prototype.pop = function(){
            return Array.prototype.pop.call(this),this;
        }
        WatchArray.prototype.shift = function(){
            return Array.prototype.shift.call(this),this;
        }
        return new WatchArray();
    }
    const WatchObject = (data, path, event) => {
        function WatchObject(){
            for(var key in data){
                this.set(key, data[key])
            }
        }
        WatchObject.prototype.set =  function(key,val){
            //调用之前创建的函数，格式化val
            data[key] = createNewWatch(val, path, key, event)
            //创建对数据key的监听
            defineProperty(this, key, data[key], path.concat(key), event)
        }
        return new WatchObject()
    }
    const b = WatchObject(data,[],{ 
        set(path,val){ 
            console.log(path,val) 
        } 
    })
    console.log(b)
</script> 
</body>
</html>